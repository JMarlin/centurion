# Centurion
Centurion is an ongoing project which I consider to be my personal self-tutorial in understanding computers from the absolute ground up. It has its roots in a stupidly ambitious project (of which I've had far too many) with the goal of constructing a computer completely from discrete RTL logic. You can find an archived version of my old about page from the project blog I started for that one all the way back in 2009 in the old_site directory, Needless to say, my focus wavered quite a bit on that one.

With this go-around I'm learning from my past experiences and will not be proclaiming this as a project that's going to ever be that serious or even ever be finished or even really started properly. I just wanted to start a repo so that, in the course of my days, I might have a place to organize my thoughts should they happen to turn to centurion.

So what am I even actually looking to accomplish here? It's a project of projects. My big, lofty, pie-in-the-sky end goal would be a super-underpowered workstation completely of my own design inclusing the major ASICs. But for realism's sake, that whole thing is going to be broken down into some discrete sub-projects:

  1) *Design a custom CPU*: This would be the core of the project as there's no computer without a processor and the processor is really one of the most educationally rich of all the components in the box. I've messed around with this a few times, thrown together some circuits in logisim, designed some ISAs, written a few simple assemblers and emulators. I'd like to break this one down as follows:
    a) *Design the ISA*: I'm not going to be building this out of discrete logic, so throw concerns of simplicity of manufacture out the window. I'm thinking something RISCy with an x86-type byte/word/dword adressing scheme. I know I want an MMU, but I'm not sure if I want it on-die or not.
    b) *Throw together an emulator*: To be extended as I come up with stuff, but it would be good to have a platform for developing software while developing the CPU. Also provides a benchmark against which I can compare the hardware development.
    c) *Write a simple assembler/compiler*: Because a platform is pretty useless without software. 
    d) *Write a Verilog/VHDL implementation of the spec*: Should be able to do initial testing on my Basys2 FPGA dev board, but when the final implementation gets close to complete I'm going to need to fab my own board with the FPGA/CPU, some RAM and some kind of simple I/O for doing proper testing of the design.
    
  2) *Write system software*: Once I have my basic dev board running, it's going to need some kind of operating system type bullshit. There's some obvious stuff I want out of this like multitasking and VFS and other cool junk, but its development will likely just follow the development of the hardware so I won't break it down.
    
  3) *Build a motherboard/enclosure*: With the CPU dev board proven, I want to design a platform for it. My ideal design would be sort of a modern take on S-100 so that I can design a CPU board that might be capable of playing with SMP should I build and plug in more than one of them. It would also let me play around easily with prototyping other boards for the system and easily allow me to add future expansions like I/O, more memory, disk controllers, video &c.
    
  4) *Design a memory board*: This is really part and parcel of 3, since the basic system would be completely useless without RAM, but it's going to be a bit of an undertaking as with any of this, so I'm making it a bullet point. This board should not only have RAM, but the system boot ROM as well onto which will be flashed the initial system software and eventually the system bootloader.
    
  5) *Design an IO board*: I want to make a single board that will allow me to attach disks to the system (because loading everything into the boot ROM isn't going to get me too far) as well as provide basic services like keyboard and mouse connections, GPIO, perhaps even basic PCM audio. This would basically end up being another FPGA board with a bus interface and a bunch of I/O breakouts.
    
  6) *Design a GPU*: I really want my system to have a neato GUI, so I want to build a video card. Video cards are also another fascinating piece of hardware as they can be as simple as a linear framebuffer with a DAC or a complex 2D or 3D accelerated piece of kit. And I want to develop it in exactly that order.
    a) *Build a generic board*: Basically, so that I can go anywhere with the design, I want to build a card with a bus interface, an FPGA and its support hardware, far more RAM than I should ever realistically need for future expansion and finally a VGA or DVI breakout (DVI, assuming the spec seems realistically implementable)
    b) *Implement a basic framebuffer*: To get things started, just throw a DAC and an address decoder into the FPGA to get things up and running as soon as possible. Maybe throw in the capacity for double-buffering as a cheap bonus. The last addon to this would be to go from a static resolution and timing that's known to work with the testing monitor to an ability to support multiple resolutions and frequencies relatively intelligently.
    c) *Tack on some 2D acceleration*: Add a command interface register to the spec and start by implementing the simple things like rectangles, flood fills, bresenham lines, arcs and other fundamental geometry. Then start playing with things like sprites and scaling/rotating. The scaling/rotating should be good preperation for the next step
    d) *Tack on some 3D acceleration*: This is scaling/rotating taken to the max. 2D polygon commands become triangle lists. Sprite memory becomes texture memory. Scaling and rotation become texture mapping.
